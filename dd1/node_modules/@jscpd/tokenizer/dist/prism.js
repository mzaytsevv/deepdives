"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Prism = require("prismjs");
const formats_1 = require("./formats");
const token_map_1 = require("./token-map");
const grammar_loader_1 = require("./grammar-loader");
const initializeFormats = () => {
    grammar_loader_1.loadLanguages();
    const ignore = {
        ignore: [
            {
                pattern: /(jscpd:ignore-start)[\s\S]*?(?=jscpd:ignore-end)/,
                lookbehind: true,
                greedy: true,
            },
            {
                pattern: /jscpd:ignore-start/,
                greedy: false,
            },
            {
                pattern: /jscpd:ignore-end/,
                greedy: false,
            },
        ],
    };
    const punctuation = {
        // eslint-disable-next-line @typescript-eslint/camelcase
        new_line: /\n/,
        empty: /\s+/,
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Prism.languages.markup.script.inside = Object.assign(Object.assign(Object.assign({}, ignore), Prism.languages.markup.script.inside), punctuation);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Prism.languages.markup.style.inside = Object.assign(Object.assign(Object.assign({}, ignore), Prism.languages.markup.style.inside), punctuation);
    Object.keys(Prism.languages).forEach((lang) => {
        Prism.languages[lang] =
            typeof Prism.languages[lang] === 'object' ? Object.assign(Object.assign(Object.assign({}, ignore), Prism.languages[lang]), punctuation) :
                Prism.languages[lang];
    });
};
initializeFormats();
function getLanguagePrismName(lang) {
    if (lang in formats_1.FORMATS && formats_1.FORMATS[lang].parent) {
        return formats_1.FORMATS[lang].parent;
    }
    return lang;
}
function tokenize(code, language) {
    let length = 0;
    let line = 1;
    let column = 1;
    function sanitizeLangName(name) {
        return name && name.replace ? name.replace('language-', '') : 'unknown';
    }
    function createTokenFromString(token, lang) {
        return [
            {
                format: lang,
                type: 'default',
                value: token,
                length: token.length,
            },
        ];
    }
    function calculateLocation(token) {
        const result = token;
        const lines = result.value.split('\n');
        const newLines = lines.length - 1;
        const start = {
            line,
            column,
        };
        column = newLines !== 0 ? lines[lines.length - 1].length + 1 : column + lines[lines.length - 1].length;
        const end = {
            line: line + newLines,
            column,
        };
        result.loc = { start, end };
        result.range = [length, length + result.length];
        length += result.length;
        line += newLines;
        return result;
    }
    function createTokenFromFlatToken(token, lang) {
        return [
            {
                format: lang,
                type: token.type,
                value: token.content,
                length: token.length,
            },
        ];
    }
    function createTokens(token, lang) {
        if (token instanceof Prism.Token && typeof token.content === 'string') {
            return createTokenFromFlatToken(token, lang);
        }
        if (token instanceof Prism.Token && Array.isArray(token.content)) {
            let res = [];
            token.content.forEach((t) => (res = res.concat(createTokens(t, token.alias ? sanitizeLangName(token.alias) : lang))));
            return res;
        }
        return createTokenFromString(token, lang);
    }
    let tokens = [];
    Prism.tokenize(code, Prism.languages[getLanguagePrismName(language)])
        .forEach((t) => (tokens = tokens.concat(createTokens(t, language))));
    return tokens.map(calculateLocation).filter((t) => t.format in formats_1.FORMATS);
}
exports.tokenize = tokenize;
function createTokenMapBasedOnCode(id, data, format, options = {}) {
    const { mode, ignoreCase } = options;
    const tokens = tokenize(data, format)
        .filter((token) => mode(token, options));
    if (ignoreCase) {
        return token_map_1.createTokensMaps(id, data, tokens.map((token) => {
            token.value = token.value.toLocaleLowerCase();
            return token;
        }), options);
    }
    return token_map_1.createTokensMaps(id, data, tokens, options);
}
exports.createTokenMapBasedOnCode = createTokenMapBasedOnCode;
//# sourceMappingURL=prism.js.map